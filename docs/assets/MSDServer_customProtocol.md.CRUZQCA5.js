import{_ as r,c as o,o as d,aj as a}from"./chunks/framework.Dq3QIEZg.js";const b=JSON.parse('{"title":"CRUX 서버 TCP 소켓 통신 및 커스텀 프로토콜","description":"","frontmatter":{},"headers":[],"relativePath":"MSDServer/customProtocol.md","filePath":"MSDServer/customProtocol.md","lastUpdated":1739198014000}'),e={name:"MSDServer/customProtocol.md"};function n(s,t,g,l,i,h){return d(),o("div",null,t[0]||(t[0]=[a('<h1 id="crux-서버-tcp-소켓-통신-및-커스텀-프로토콜" tabindex="-1">CRUX 서버 TCP 소켓 통신 및 커스텀 프로토콜 <a class="header-anchor" href="#crux-서버-tcp-소켓-통신-및-커스텀-프로토콜" aria-label="Permalink to &quot;CRUX 서버 TCP 소켓 통신 및 커스텀 프로토콜&quot;">​</a></h1><h2 id="_1-개요" tabindex="-1">1. 개요 <a class="header-anchor" href="#_1-개요" aria-label="Permalink to &quot;1. 개요&quot;">​</a></h2><p>CRUX 서버에서는 <strong>실시간 데이터 수집 및 처리</strong>를 위해<br><strong>TCP 소켓 통신을 활용하여 클라이언트와 서버 간의 고속 통신을 구현</strong>하였습니다.<br> 또한, <strong>커스텀 프로토콜을 정의하여 데이터를 구조화</strong>하여 송수신할 수 있도록 설계하였습니다.</p><h2 id="_2-tcp-소켓-통신-구조" tabindex="-1">2. TCP 소켓 통신 구조 <a class="header-anchor" href="#_2-tcp-소켓-통신-구조" aria-label="Permalink to &quot;2. TCP 소켓 통신 구조&quot;">​</a></h2><p>![프로토콜](/images/TCP소켓 프로토콜.png)</p><h3 id="🔹-tcp-소켓-통신의-역할" tabindex="-1">🔹 <strong>TCP 소켓 통신의 역할</strong> <a class="header-anchor" href="#🔹-tcp-소켓-통신의-역할" aria-label="Permalink to &quot;🔹 **TCP 소켓 통신의 역할**&quot;">​</a></h3><ul><li><strong>Edge Clients</strong> → 실시간 센서 및 장비 데이터 수집</li><li><strong>CRUX Server</strong> → TCP 스트리밍 데이터를 수신 및 처리</li><li><strong>TimescaleDB</strong> → 수집된 데이터를 저장하여 실시간 분석 수행</li></ul><p>TCP 소켓을 이용하여 <strong>지연시간(Latency)을 최소화</strong>하면서<br><strong>고속 데이터 전송이 가능하도록 설계</strong>하였습니다.</p><h2 id="_3-커스텀-프로토콜-설계" tabindex="-1">3. 커스텀 프로토콜 설계 <a class="header-anchor" href="#_3-커스텀-프로토콜-설계" aria-label="Permalink to &quot;3. 커스텀 프로토콜 설계&quot;">​</a></h2><h3 id="🔹-데이터-전송-프로토콜" tabindex="-1">🔹 <strong>데이터 전송 프로토콜</strong> <a class="header-anchor" href="#🔹-데이터-전송-프로토콜" aria-label="Permalink to &quot;🔹 **데이터 전송 프로토콜**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>필드명</th><th>크기(Bytes)</th><th>설명</th></tr></thead><tbody><tr><td><strong>FrameType</strong></td><td>1</td><td>프레임 유형 (데이터, 인증 등)</td></tr><tr><td><strong>Length</strong></td><td>2</td><td>전체 패킷 길이</td></tr><tr><td><strong>Version</strong></td><td>1</td><td>프로토콜 버전</td></tr><tr><td><strong>Role</strong></td><td>1</td><td>클라이언트 역할 (Edge, Admin 등)</td></tr><tr><td><strong>Reserved</strong></td><td>1</td><td>예약 필드 (확장용)</td></tr><tr><td><strong>Payload (Data)</strong></td><td>40</td><td>센서 데이터 (40 Bytes)</td></tr></tbody></table><ul><li>데이터를 <strong>일정한 패킷 구조로 전송</strong>하여 <strong>서버가 효율적으로 파싱 가능</strong></li><li><strong>40바이트 크기의 페이로드</strong>로 센서 데이터를 구성하여 <strong>최적화된 데이터 처리 가능</strong></li></ul><h3 id="🔹-jwt-인증-프로토콜" tabindex="-1">🔹 <strong>JWT 인증 프로토콜</strong> <a class="header-anchor" href="#🔹-jwt-인증-프로토콜" aria-label="Permalink to &quot;🔹 **JWT 인증 프로토콜**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>필드명</th><th>크기(Bytes)</th><th>설명</th></tr></thead><tbody><tr><td><strong>FrameType</strong></td><td>1</td><td>프레임 유형 (인증 요청)</td></tr><tr><td><strong>Length</strong></td><td>2</td><td>전체 패킷 길이</td></tr><tr><td><strong>Version</strong></td><td>1</td><td>프로토콜 버전</td></tr><tr><td><strong>Role</strong></td><td>1</td><td>클라이언트 역할 (Edge, Admin 등)</td></tr><tr><td><strong>Reserved</strong></td><td>1</td><td>예약 필드 (확장용)</td></tr><tr><td><strong>Payload (JWT Token)</strong></td><td>가변 길이</td><td>JWT 보안 토큰</td></tr></tbody></table><ul><li><strong>JWT 기반 인증을 적용하여 TCP 통신에서도 보안 강화</strong></li><li><strong>서버는 클라이언트가 제공한 JWT 토큰을 검증한 후 데이터 요청을 허용</strong></li><li><strong>비인가 클라이언트의 접근을 방지하여 데이터 무결성 확보</strong></li></ul><h2 id="_4-tcp-커스텀-프로토콜의-기대-효과" tabindex="-1">4. TCP 커스텀 프로토콜의 기대 효과 <a class="header-anchor" href="#_4-tcp-커스텀-프로토콜의-기대-효과" aria-label="Permalink to &quot;4. TCP 커스텀 프로토콜의 기대 효과&quot;">​</a></h2><table tabindex="0"><thead><tr><th>기존 방식 문제점</th><th>개선 사항</th></tr></thead><tbody><tr><td>REST API 기반 데이터 수집 시 지연 발생</td><td><strong>TCP 소켓을 이용한 고속 데이터 전송으로 해결</strong></td></tr><tr><td>데이터 포맷이 일정하지 않아 파싱 비용 증가</td><td><strong>커스텀 프로토콜을 적용하여 구조화된 데이터 처리 가능</strong></td></tr><tr><td>클라이언트 인증이 부족하여 보안 취약</td><td><strong>JWT 기반 인증 적용으로 보안 강화</strong></td></tr><tr><td>대량의 실시간 데이터 저장 시 성능 저하</td><td><strong>TimescaleDB와 연동하여 대량 데이터 처리 최적화</strong></td></tr></tbody></table><h2 id="_5-결론" tabindex="-1">5. 결론 <a class="header-anchor" href="#_5-결론" aria-label="Permalink to &quot;5. 결론&quot;">​</a></h2><p>✅ <strong>TCP 소켓 기반으로 실시간 고속 데이터 전송 구현</strong><br> ✅ <strong>커스텀 프로토콜 적용으로 패킷 구조화 및 데이터 처리 최적화</strong><br> ✅ <strong>JWT 인증을 활용하여 TCP 통신의 보안 강화</strong><br> ✅ <strong>TimescaleDB와 연계하여 대용량 실시간 데이터 저장 및 분석 가능</strong></p><p>CRUX 서버의 TCP 커스텀 프로토콜은 <strong>고성능 실시간 데이터 처리 및 보안성을 갖춘 네트워크 아키텍처</strong>를 제공합니다. 🚀</p>',20)]))}const T=r(e,[["render",n]]);export{b as __pageData,T as default};
